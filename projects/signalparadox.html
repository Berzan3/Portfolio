<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signalparadox - Dev Portfolio</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="../js/main.js" defer></script>
</head>
<body>
<!-- Navigation Header -->
<header>
    <nav>
        <div class="nav-container">
            <div class="logo">
                <h1>Andreas Berzelius</h1>
            </div>
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>
                <li><a href="../projects.html" class="active">Projects</a></li>
                <li><a href="../cv.html">CV</a></li>
            </ul>
        </div>
    </nav>
</header>

<main class="project-detail">
    <div class="detail-header">
        <h2>Signalparadox</h2>
        <h3>made back in around 2020</h3>
        <p class="tagline">A third person horror puzzle game</p>
        <div class="project-tags">
            <span class="tag">Unity</span>
            <span class="tag">C#</span>
            <span class="tag">PC</span>
        </div>
    </div>

    <div class="detail-section">
        <div class="media-grid">
            <div class="media-item">
                <video controls>
                    <source src="../assets/signalparadox/signalparadox_demo.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>
        </div>
    </div>

    <div class="detail-section">
        <h3>Overview</h3>
        <p>
            In SignalParadox you play as Livia Skye who wakes up on an alien infested spaceship trying to figure out what's going on and how to get out.
            You sneak past aliens and solve puzzles in order to make it out alive.
            The game concept is basically to stealth and solve puzzles through an exciting and scary environment.
        </p>
    </div>

    <div class="detail-section">
        <h3>Notable stuff</h3>
        <div class="workflow-list">
            <ul>
                <li>creating the Decoygrenade</li>
                <li>making the ChargerEnemy</li>
                <li>Animations</li>
                <li>Pickup</li>
                <li>Triggers</li>
                <li>The team size was 5</li>
                <li>development time was around 9 weeks</li>
            </ul>
        </div>
    </div>

    <div class="detail-section">
        <h3>My role</h3>
        <p>
            Me and my colleagues had several roles in the project because we were so few,
            and we weren't sure of what roles we had under the project.
            In the end my roles in the project had been input programmer, Gameplay designer and Ai programmer.
        </p>
        <br />
        <h4>My tasks</h4>

        <div class="media-item">
            <img src="../assets/signalparadox/grenade_throw.gif" alt="grenade throw">
        </div>

        <br />
        <h4>Decoygrenade</h4>
        <p>
            The player can pick up and throw a decoygrenade to lure a certain alien to it so
            that they can more safely walk by under a limited time.
            The trajectory of the grenade is visualized while aiming so the player could aim more easily.
            If the player aims out of range the visualization and animation stops.
        </p>
        <br />

        <p>
            To make the visualization of the grenades trajectory look better than just a colored thin line
            I made a simple texture that makes the linerenderer look dotted.
        </p>

        <div class="media-item">
            <img src="../assets/signalparadox/dotted_line.png" alt="dotted line texture">
        </div>

        </div>

    <div class="detail-section">
        <button class="btn btn-small show-code-btn" onclick="toggleCode(this)">Show Code</button>
        <div class="code-container" style="display: none;">
            <p>ThrowDecoyGrenade.cs</p>
            <div class="code-snippet">
                    <pre><code>
private void Throw()
      {
          shouldDrawPath = false;
          currentState = States.HoldingNoGrenade;
          onThrowEvent?.Invoke();
          if (thrownGrenade != null)
          {
              Destroy(thrownGrenade.gameObject);
              StopCoroutine(despawnGrenadeCoroutine);
          }
          thrownGrenade = Instantiate(grenadePrefabRigidbody,
            grenadeProp.position, grenadeProp.rotation);
          thrownGrenade.AddForce(Vector3.up * gravity);
          thrownGrenade.velocity = CalculateLaunchData().initialVelocity;
          hasGrenade = false;
          despawnGrenadeCoroutine = StartCoroutine(DespawnGrenade());
      }

      private LaunchData CalculateLaunchData()
      {
          Vector3 newTarget = GetTarget().point;
          if (GetTarget().collider && (newTarget.y - grenadeProp.position.y) < currentThrowHeight)
          {
              float displacementY = newTarget.y - grenadeProp.position.y;
              Vector3 displacementXZ = new Vector3(newTarget.x - grenadeProp.position.x, 0,
                newTarget.z - grenadeProp.position.z);
              float time = Mathf.Sqrt(-2 * currentThrowHeight / gravity) +
              Mathf.Sqrt(2 * (displacementY - currentThrowHeight) / gravity);
              Vector3 velocityY = Vector3.up * Mathf.Sqrt(-2 * gravity * currentThrowHeight);
              Vector3 velocityXZ = displacementXZ / time;
              return new LaunchData(velocityXZ + velocityY * -Mathf.Sign(gravity), time);
          }
          onAbortAimEvent?.Invoke();
          return new LaunchData(Vector3.zero, 0f);
      }

      private void DrawPath()
      {
          if (currentState == States.Disabled || currentState == States.Occupied)
          {
              StopAiming();
              return;
          }
          LaunchData launchData = CalculateLaunchData();
          if (launchData.initialVelocity != Vector3.zero && launchData.timeToTarget != 0f)
          {
              Vector3 previousDrawPoint = grenadeProp.position;
              onAimingEvent?.Invoke();
              for (int i = 0; i <= lineRendererResolution; i++)
              {
                  float simulationTime = i / (float)lineRendererResolution * launchData.timeToTarget;
                  Vector3 displacement = launchData.initialVelocity * simulationTime +
                  Vector3.up * gravity * simulationTime * simulationTime / 2f;
                  Vector3 drawPoint = grenadeProp.position + displacement;
                  previousDrawPoint = drawPoint;
                  AddLinePoint(previousDrawPoint);
                  currentState = States.Aiming;
              }
          }
          else
          {
              currentState = States.HoldingGrenade;
              shouldDrawPath = false;
          }
      }
                    </code></pre>
            </div>
        </div>
    </div>

    <div class="detail-section">

        <p>
            After a certain time or if the player picks up another grenade the currently thrown grenade gets erased.
        </p>

        <div class="media-grid">
            <div class="media-item">
                <img src="../assets/signalparadox/grenade_throw_enemies.gif" alt="grenade throw enemies">
            </div>
        </div>

        <p>
            The script for getting the aliens to chase the grenade was made by my co-programmer
        </p>
        <br />

        <div class="media-item">
            <img src="../assets/signalparadox/charger_charging.gif" alt="charger charging">
        </div>

        <h4>Charger Enemy</h4>
        <p>
            The ChargerEnemy is an enemy that charges at the player at a very fast speed and if the player
            is caught in the charge the player dies when the charger smashes into something.
        </p>
        <br />

        <p>The charger has several states it switches between and uses a navmesh agent to move around.
            The Charger´s states are: Patrolstate, huntstate, chargeupstate, chargestate, stunstate, deadstate.
            In Patrolstate the charger patrols between his waypoints until he sees the player.
            Hunstate the charger sees the player and is actively chasing the player to go into chargeupstate.
            Chargeupstate the charger stops briefly before charging against the player.
            ChargeState the charger charges at the player.
            Stunstate happens after the charger has charged into something where he is stunned for a brief moment.
            Deadstate the charger is dead and can only happen if the charger charges into a glasswall or laser.
        </p>

        <div class="media-item">
            <img src="../assets/signalparadox/charger_inspect_window.png" alt="charger inspect window">
        </div>

        <p>
            At first, I tried to use a boxcollider with ontriggerEnter to know when it has stopped charging
            but after some time working on the project my co-programmer suggested
            I could just measure the speed after it has started charging and measure to see if it decreases.
        </p>
        </div>

    <div class="detail-section">
        <button class="btn btn-small show-code-btn" onclick="toggleCode(this)">Show Code</button>
        <div class="code-container" style="display: none;">
            <p>ChargeState.cs</p>
            <div class="code-snippet">
                    <pre><code>
namespace AI.Charger.AIStateMachine
{
  [CreateAssetMenu(menuName = "AIStates/Charger/ChargeState")]
  public class ChargeState : ChargerBaseState
  {
      [SerializeField] private float chargeSpeed;
      [SerializeField] private AudioClip hitWallSound;
      [SerializeField] private AudioClip startChargeSound;
      [SerializeField] private float wallSoundThreshold = 10f;
      [SerializeField] private float destroyGlassThreshold = 20f;
      private float previousFrameSpeed;
      public static Action&lt;GameObject&gt; onChargeEvent, onStunnedEvent, onSlowChargeEvent, onFastChargeEvent;

      public override void Enter()
      {
          base.Enter();
          Ai.AudioSource.PlayOneShot(startChargeSound);
          onChargeEvent?.Invoke(Ai.gameObject);
      }

      public override void Run()
      {
          if (previousFrameSpeed - Ai.aiRigidbody.velocity.magnitude > 0f)
              ChargeEnded();
          Charge();
      }

      private void Charge()
      {
          previousFrameSpeed = Ai.aiRigidbody.velocity.magnitude;
          Ai.aiRigidbody.AddForce(Ai.ChargeDirection.normalized * (chargeSpeed * Time.deltaTime));
          if (Ai.aiRigidbody.velocity.magnitude > destroyGlassThreshold)
              onFastChargeEvent?.Invoke(Ai.gameObject);
          if (!Ai.EnemyTrigger.IsTouchingTaggedObject) return;
          Ai.target.transform.parent = Ai.transform;
          Ai.CaughtPlayer();
      }

      private void ChargeEnded()
      {
          if (previousFrameSpeed - Ai.aiRigidbody.velocity.magnitude > wallSoundThreshold)
          {
              Ai.AudioSource.PlayOneShot(hitWallSound);
              onStunnedEvent?.Invoke(Ai.gameObject);
          }
          else
              onSlowChargeEvent?.Invoke(Ai.gameObject);
          Ai.aiRigidbody.velocity = Vector3.zero;
          previousFrameSpeed = 0f;
          if (Ai.target.transform.IsChildOf(Ai.transform))
              Ai.KillPlayer();
          Ai.target.transform.parent = null;
          Ai.agent.enabled = true;
          stateMachine.TransitionTo&lt;StunState&gt;();
      }
  }
}
                    </code></pre>
            </div>
        </div>
    </div>

    <div class="detail-section">
        <p>
            The charger is part of a puzzle the player must solve by dodging and luring the charger to charge into a glass wall.
            If the charger reaches a certain minimum speed and charges into the glasswall it destroys the wall creating a path and then dies.
        </p>

        <div class="media-item">
            <img src="../assets/signalparadox/charger_destroy_glass.gif" alt="charger destroy glass">
        </div>

    </div>

    <div class="detail-section">
        <button class="btn btn-small show-code-btn" onclick="toggleCode(this)">Show Code</button>
        <div class="code-container" style="display: none;">
            <p>GlassWallTrigger.cs</p>
            <div class="code-snippet">
                    <pre><code>
    namespace Interactables.Triggers.Events

    blic class GlassWallTrigger : MonoBehaviour

      [SerializeField] private float chargerLookAngle = 0.5f;
      private BoxCollider[] colliers;
      private Animator animator;
      private AudioSource audioSource;
      private bool isDestroyable;
      private Vector3 glassForward;

      public static Action onBrokenEvent;

      private void Awake()
      {
          colliers = GetComponents&lt;BoxCollider&gt;();
          animator = GetComponent&lt;Animator&gt;();
          audioSource = GetComponent&lt;AudioSource&gt;();
          glassForward = new Vector3(transform.forward.x, 0, transform.forward.z);

          ChargeState.onStunnedEvent += charger => isDestroyable = false;
          ChargeState.onSlowChargeEvent += charger => isDestroyable = false;
          ChargeState.onFastChargeEvent += charger => isDestroyable = true;
      }

      private void OnDestroy()
      {
          ChargeState.onStunnedEvent -= charger => isDestroyable = false;
          ChargeState.onSlowChargeEvent -= charger => isDestroyable = false;
          ChargeState.onFastChargeEvent -= charger => isDestroyable = false;
      }

      private void OnTriggerEnter(Collider other)
      {
          if (!isDestroyable) return;
          var chargerForward = new Vector3(other.transform.forward.x, 0, other.transform.forward.z);
          if (other.CompareTag("Enemy") && Vector3.Dot(glassForward, chargerForward) > chargerLookAngle)
              DestoryWall();
      }

      private void DestoryWall()
      {
          for (var i = 0; i &lt; colliers.Length; i++)
          {
              colliers[i].enabled = false;
          }
          animator.SetTrigger("GlassBreak");
          audioSource.Play();
          onBrokenEvent?.Invoke();
      }


                    </code></pre>
            </div>
        </div>
    </div>

    <div class="detail-section">
        <h4>Miscellaneous</h4>
        <p>
            To make the grenade pickup more realistic and look better
            I wanted the grenade in the players hand to appear when the animation of the pickup reached out and grabbed.
            So my first thought was to make a timer in the script to decide when
            to enable the grenade, but then I realised I could make it much easier with an animation event.
        </p>

        <div class="media-item">
            <img src="../assets/signalparadox/grenade_pickup_animation.gif" alt="grenade pickup animation">
        </div>
        <br/>

        <p>
            To make the transition between levels feel smoother
            I made a simple fade in with an elevator sound which triggers at the end of a level,
            when the elevator sound has finished the player is taken to the next level.
        </p>

        <div class="media-item">
            <img src="../assets/signalparadox/fade_in_level_transition.gif" alt="fade in level transition">
        </div>
        <br />

        <p>
            My programming colleague advised me to make a simple Hinge joint motor
            instead of an animation to make this cool machine one of my designers made spin.
        </p>

        <div class="media-item">
            <img src="../assets/signalparadox/motor_spin.gif" alt="motor spin">
        </div>
    </div>

    <div class="detail-section">
        <h3>The process</h3>
        <p>
            This was one of my biggest game projects I've helped make at university so far.
            I was really exhausted in the beginning of the project because of a previously very intense programming course
            and that in the beginning of this course we had to make a 2d and 3d controller.
            The objective with the project was to make a 3D game.
        </p>
    </div>

    <div class="detail-section">
        <h3>Challenges</h3>
        <p>
            This was a big challenge, I had never made a project of this size before with so many people. My Unity and C# knowledge was also a bit novice.
            Another challenge was that our group wanted the grenade trajectory to be visualized like a parabola of some sort.
            I was in charge of the grenade and I had never made something so complex with a linerenderer before.
            I looked up articles and videos on the internet to understand the math for calculating the curve. After I got down the math, the rest went easier.
        </p>
    </div>

    <div class="detail-section">
        <h3>Iteration</h3>
        <p>
            The ChargerEnemy had to have it´s Charge Mechanism reworked several times throughout the project until it was bug free and felt good.
            As my first big Game project, with only a limited amount of Unity and programming knowledge,
            I definitely struggled with my tasks. But this is what my colleagues expected me to make,
            so I worked a lot to make sure it worked in the end.
            I'm also very thankful for my more experienced co-programmer who I could always ask questions or get help from if I needed it.

            Looking back through my weekly reviews of my work and how my code improved through the project,
            I'm proud of how I fought to make sure it worked because I learned a lot in the process.
        </p>
    </div>

    <a href="../projects.html" class="back-link">← Back to Projects</a>
</main>

<footer>
    <p>&copy; 2025 Andreas Berzelius. All rights reserved.</p>
</footer>
</body>
</html>
